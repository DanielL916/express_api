/**
 * Created by zenit1 on 21/12/2016.
 */

"use strict";

const fs          = require("fs");
const request     = require('request');
const apiEndpoint = 'https://aio.hvca.globalsign.com:3011';
const path        = require('path');
const execFile    = require('child_process').execFile;


const beameUtils        = require('../../src/utils/BeameUtils');
const OpenSSlWrapper    = new (require('../../src/utils/OpenSSLWrapper'))();
const DirectoryServices = require('../../src/services/DirectoryServices');


const api_key = 'bf76fcfb4e13519b',
      api_secret = 'a809797d609af14bccdce6f4fe1e4a89fd7d397e';

//noinspection JSUnusedLocalSymbols
const policy = {
	"validity":             {
		"secondsmin":               1,
		"secondsmax":               31540000,
		"not_before_negative_skew": 60,
		"not_before_positive_skew": 60
	},
	"subject_dn":           {
		"common_name":                                          "REQUIRED",
		"common_name_format":                                   "\\A.+\\.beame\\.io",
		"email":                                                "FORBIDDEN",
		"country":                                              "FORBIDDEN",
		"state":                                                "FORBIDDEN",
		"locality":                                             "FORBIDDEN",
		"street_address":                                       "FORBIDDEN",
		"jurisdiction_of_incorporation_locality_name":          "FORBIDDEN",
		"jurisdiction_of_incorporation_state_or_province_name": "FORBIDDEN",
		"jurisdiction_of_incorporation_country_name":           "FORBIDDEN",
		"organization":                                         "OPTIONAL",
		"business_category":                                    "FORBIDDEN",
		"organizational_unit":                                  "OPTIONAL"
	},
	"san_dns_names":        {
		"mincount": 0,
		"maxcount": 1,
		"format":   "\\A.+\\.beame\\.io"
	},
	"san_emails":           {
		"mincount": 0,
		"maxcount": 0
	},
	"san_uris":             {
		"mincount": 0,
		"maxcount": 0
	},
	"san_ip_addresses":     {
		"mincount": 0,
		"maxcount": 0
	},
	"public_key":           {
		"key_type":        "RSA",
		"allowed_lengths": [
			2048
		]
	},
	"public_key_signature": "REQUIRED"
};

//require('request-debug')(request);
const fqdn    = 'hvca13.beame.io',
      dirPath = path.join(__dirname, '..', 'certs', fqdn);


//console.log(options);

const readFile = (path) => {
	return fs.readFileSync(path, 'utf8');

};

const getAccessToken = () => {
	return new Promise((resolve, reject) => {

			let data          = {
				    api_key,
				    api_secret
			    },
			    formData      = JSON.stringify(data),
			    contentLength = formData.length;

			let options = {
				cert:    fs.readFileSync("./certs/x509.pem"),
				key:     fs.readFileSync("./certs/pk.pem"),
				ca:      fs.readFileSync("./certs/ca.pem"),
				body:    formData,
				headers: {
					'Content-Length': contentLength,
					'Content-Type':   'application/json;charset=utf-8'
				}
			};
			request.post(
				apiEndpoint + '/login',
				options,
				function (error, response, body) {

					if (response.statusCode !== 200) {
						reject(error || response);
					}

					try {
						let data         = JSON.parse(body),
						    access_token = data.access_token;

						resolve(access_token);

					} catch (e) {
						reject('parse body error', e);
					}
				}
			);
		}
	);

};

const createPrivateKey = () => {
	return new Promise((resolve, reject) => {
			OpenSSlWrapper.createPrivateKey().then(pk => {

				//console.log('***************************pk received***********************************');
				//console.log(pk);


				//console.log('path is ', dirPath);

				DirectoryServices.createDir(dirPath);

				DirectoryServices.saveFile(dirPath, 'private_key.pem', pk, error => {
					if (!error) {
						resolve();

					}
					else {
						reject(error);
					}
				})


			}).catch(function (error) {
				reject(error);
			});
		}
	);
};

const savePublicKey = () => {
	return new Promise((resolve, reject) => {
			let pkFile = beameUtils.makePath(dirPath, 'private_key.pem');

			//console.log(`private key path ${pkFile}`);

			let action = "openssl",
			    args   = ['rsa', '-in', pkFile, '-pubout',  '-out', path.join(dirPath, 'public_key.pem')];

			try {
				execFile(action, args, function (error) {
					if (error) {
						reject(error);
						return;
					}

					//console.log('***************************public key saved***********************************');

					resolve();

				});
			}
			catch (e) {
				reject(e);
			}
		}
	);
};

const savePublicKeyDer = () => {
	return new Promise((resolve, reject) => {
			let pkFile = beameUtils.makePath(dirPath, 'public_key.pem');

			//console.log(`public key path ${pkFile}`);

			let action = "openssl",
			    args   = ['rsa', '-pubin', '-in', pkFile, '-outform', 'DER', '-out', path.join(dirPath, 'public_key.der')];

			try {
				execFile(action, args, function (error) {
					if (error) {
						reject(error);
						return;
					}

					//console.log('***************************public key der saved***********************************');

					resolve();

				});
			}
			catch (e) {
				reject(e);
			}
		}
	);
};

const savePublicKeySignature = () => {
	return new Promise((resolve, reject) => {
			let private_key    = path.join(dirPath, 'private_key.pem'),
			    public_key_der = path.join(dirPath, 'public_key.der'),
			    temp_signature = path.join(dirPath, 'sign.sha256'),
			    signature      = path.join(dirPath, 'sign.txt');


			let action = "openssl",
			    args   = ['dgst', '-sha256', '-sign', private_key, '-out', temp_signature, public_key_der];

			try {
				execFile(action, args, function (error) {
					if (error) {
						reject(error);
						return;
					}

					//console.log('***************************public key signature sha256 saved***********************************');

					args = ['base64', '-in', temp_signature, '-out', signature];

					execFile(action, args, function (error) {
						if (error) {
							reject(error);
							return;
						}

						resolve();
					});

				});
			}
			catch (e) {
				reject(e);
			}
		}
	);
};

const orderCert = (access_token) => {

	return new Promise((resolve, reject) => {
			let data = {
				"public_key":           readFile(path.join(dirPath, 'public_key.pem')),
				"public_key_signature": readFile(path.join(dirPath, 'sign.txt')),
				"subject_dn":           {
					"common_name": fqdn
					//"common_name_format":                                   "\\A.+\\.beame\\.io"
				},
				"san_dns_names":['sub.'+fqdn +'.gmail.com','192-168-1-1.' + fqdn],
				"validity":             {
					"not_before": parseInt(new Date().getTime() / 1000),
					"not_after":  0

				}
			};


			console.log(data);

			let formData      = JSON.stringify(data),
			    contentLength = formData.length;

			let options = {
				cert:    fs.readFileSync("./certs/x509.pem"),
				key:     fs.readFileSync("./certs/pk.pem"),
				ca:      fs.readFileSync("./certs/ca.pem"),
				body:    formData,
				headers: {
					'Content-Length': contentLength,
					'Content-Type':   'application/json;charset=utf-8',
					'Authorization':  `Bearer ${access_token}`
				}
			};

			request.post(
				apiEndpoint + '/certificates',
				options,
				function (error, response) {

					if (response.statusCode !== 201) {
						reject(error || response);
					}

					try {
						let location = response.headers.location;

						if(!location) reject('location not found');

						resolve(location);

					} catch (e) {
						reject('parse headers error', e);
					}
				}
			);
		}
	);
};

const getCert = (access_token,location) =>{
	let options = {
		cert:    fs.readFileSync("./certs/x509.pem"),
		key:     fs.readFileSync("./certs/pk.pem"),
		ca:      fs.readFileSync("./certs/ca.pem"),
		headers: {
			'Authorization':  `Bearer ${access_token}`
		}
	};

	request.get(
		apiEndpoint  + location,
		options,
		function (error, response, body) {

			if (response.statusCode !== 200) {
				return;
			}

			try {
				let resp = JSON.parse(body),
				    cert = resp.certificate;

				console.log('***************************X509 received***********************************');
				console.log(cert);

			} catch (e) {

			}
		}
	);
};

getAccessToken().then(access_token => {
	//console.log('***************************access_token received***********************************');
	//console.log(access_token);

	createPrivateKey().then(savePublicKey).then(savePublicKeyDer).then(savePublicKeySignature).then(() => {
		orderCert(access_token).then(getCert.bind(null,access_token)).then( data =>{

		}).catch(error => {
			console.error('order cert error', error);
		});
	}).catch(error => {
		console.error('create keys error', error);
	});

}).catch(error => {
	console.error('get token error', error);
});

